use anyhow::{anyhow, Context, Result};
use flate2::read::GzDecoder;
use std::collections::HashMap;
use std::fs::File;
use std::io::{BufRead, BufReader};
use std::path::Path;

mod ancestry;
mod ftdna;
mod myheritage;
mod plink;
mod tsv_parser;
mod twentythree;
mod vcf;

pub use self::vcf::VcfParser;
pub use ancestry::AncestryDNAParser;
pub use ftdna::FTDNAParser;
pub use myheritage::MyHeritageParser;
pub use plink::PlinkParser;
pub use tsv_parser::TsvParser;
pub use twentythree::TwentyThreeAndMeParser;

use crate::types::*;

/// Main parser that auto-detects file format and parses accordingly
pub struct FileParser {
    vcf_parser: VcfParser,
    ancestry_parser: AncestryDNAParser,
    ftdna_parser: FTDNAParser,
    myheritage_parser: MyHeritageParser,
    plink_parser: PlinkParser,
    tsv_parser: TsvParser,
    twentythree_parser: TwentyThreeAndMeParser,
}

impl FileParser {
    pub fn new() -> Self {
        Self {
            vcf_parser: VcfParser::new(),
            ancestry_parser: AncestryDNAParser::new(),
            ftdna_parser: FTDNAParser::new(),
            myheritage_parser: MyHeritageParser::new(),
            plink_parser: PlinkParser::new(),
            tsv_parser: TsvParser::new(),
            twentythree_parser: TwentyThreeAndMeParser::new(),
        }
    }

    /// Auto-detect file format and parse
    pub fn parse(&self, path: &Path) -> Result<ParsedGeneticData> {
        let format = self.detect_format(path)?;

        match format {
            FileFormat::VCF | FileFormat::BCF => self.vcf_parser.parse(path),
            FileFormat::AncestryDNA => self.ancestry_parser.parse(path),
            FileFormat::FTDNA => self.ftdna_parser.parse(path),
            FileFormat::MyHeritage => self.myheritage_parser.parse(path),
            FileFormat::PLINK => self.plink_parser.parse(path),
            FileFormat::AndMe => self.twentythree_parser.parse(path),
            FileFormat::CSV | FileFormat::TSV | FileFormat::TXT => {
                // Try to detect specific format from content
                self.detect_and_parse_generic(path)
            }
            _ => Err(anyhow!("Unsupported file format: {:?}", format)),
        }
    }

    /// Detect file format from extension and content
    fn detect_format(&self, path: &Path) -> Result<FileFormat> {
        let ext = path.extension().and_then(|e| e.to_str()).unwrap_or("");

        // Handle compressed files
        let ext = if ext == "gz" || ext == "bgz" {
            path.file_stem()
                .and_then(|s| s.to_str())
                .and_then(|s| s.rfind('.').map(|i| &s[i + 1..]))
                .unwrap_or("")
        } else {
            ext
        };

        let format = FileFormat::from_extension(ext);

        if format != FileFormat::Unknown {
            return Ok(format);
        }

        // Try to detect from content
        self.detect_format_from_content(path)
    }

    fn detect_format_from_content(&self, path: &Path) -> Result<FileFormat> {
        let file = File::open(path)?;
        let mut reader: Box<dyn BufRead> = if path.extension().map(|e| e == "gz").unwrap_or(false) {
            Box::new(BufReader::new(GzDecoder::new(file)))
        } else {
            Box::new(BufReader::new(file))
        };

        let mut first_lines = String::new();
        for _ in 0..10 {
            let mut line = String::new();
            if reader.read_line(&mut line)? == 0 {
                break;
            }
            first_lines.push_str(&line);
        }

        // Check for VCF
        if first_lines.starts_with("##fileformat=VCF") {
            return Ok(FileFormat::VCF);
        }

        // Check for 23andMe
        if first_lines.contains("# This data file generated by 23andMe") {
            return Ok(FileFormat::AndMe);
        }

        // Check for AncestryDNA
        if first_lines.contains("#AncestryDNA") || first_lines.contains("AncestryDNA") {
            return Ok(FileFormat::AncestryDNA);
        }

        // Check for FTDNA
        if first_lines.contains("RSID,CHROMOSOME,POSITION,RESULT") {
            return Ok(FileFormat::FTDNA);
        }

        // Check for MyHeritage
        if first_lines.contains("MyHeritage") || first_lines.contains("RSID,CHROMOSOME,POSITION") {
            return Ok(FileFormat::MyHeritage);
        }

        // Check for PLINK
        if path.with_extension("bim").exists() || path.with_extension("fam").exists() {
            return Ok(FileFormat::PLINK);
        }

        // Default to TSV/CSV based on delimiter
        if first_lines.contains('\t') {
            Ok(FileFormat::TSV)
        } else if first_lines.contains(',') {
            Ok(FileFormat::CSV)
        } else {
            Ok(FileFormat::TXT)
        }
    }

    fn detect_and_parse_generic(&self, path: &Path) -> Result<ParsedGeneticData> {
        // Try to detect format from headers
        let file = File::open(path)?;
        let mut reader: Box<dyn BufRead> = if path.extension().map(|e| e == "gz").unwrap_or(false) {
            Box::new(BufReader::new(GzDecoder::new(file)))
        } else {
            Box::new(BufReader::new(file))
        };

        let mut header_line = String::new();
        loop {
            header_line.clear();
            reader.read_line(&mut header_line)?;
            if header_line.starts_with('#') {
                continue;
            }
            break;
        }

        let header_lower = header_line.to_lowercase();

        // Check for 23andMe format
        if header_lower.contains("rsid")
            && header_lower.contains("chromosome")
            && header_lower.contains("position")
            && header_lower.contains("genotype")
        {
            return self.twentythree_parser.parse(path);
        }

        // Check for AncestryDNA format
        if header_lower.contains("rsid")
            && header_lower.contains("chromosome")
            && header_lower.contains("position")
            && header_lower.contains("allele")
        {
            return self.ancestry_parser.parse(path);
        }

        // Default to TSV parser
        self.tsv_parser.parse(path)
    }
}

/// Trait for format-specific parsers
pub trait GeneticDataParser {
    fn parse(&self, path: &Path) -> Result<ParsedGeneticData>;
}

/// Parsed genetic data container
#[derive(Debug, Clone)]
pub struct ParsedGeneticData {
    pub metadata: SampleMetadata,
    pub variants: HashMap<Coordinate, Variant>,
    pub hla_alleles: Vec<HLAAllele>,
    pub quality_metrics: QualityMetrics,
}

impl ParsedGeneticData {
    pub fn new(sample_id: String, source_file: String, format: FileFormat) -> Self {
        Self {
            metadata: SampleMetadata {
                sample_id,
                source_file,
                file_format: format,
                genome_build: "GRCh37".to_string(),
                sequencing_platform: None,
                call_rate: None,
                heterozygosity: None,
            },
            variants: HashMap::new(),
            hla_alleles: Vec::new(),
            quality_metrics: QualityMetrics {
                snp_count: 0,
                no_call_rate: 0.0,
                heterozygosity_rate: 0.0,
                ti_tv_ratio: 0.0,
                read_depth_mean: None,
                read_depth_std: None,
            },
        }
    }

    pub fn add_variant(&mut self, variant: Variant) {
        let coord = Coordinate::new(&variant.chromosome, variant.position);
        self.variants.insert(coord, variant);
    }

    pub fn get_variant(&self, chromosome: &str, position: u64) -> Option<&Variant> {
        let coord = Coordinate::new(chromosome, position);
        self.variants.get(&coord)
    }

    pub fn calculate_quality_metrics(&mut self) {
        let total = self.variants.len();
        if total == 0 {
            return;
        }

        let no_calls = self
            .variants
            .values()
            .filter(|v| v.genotype.is_no_call())
            .count();

        let heterozygous = self
            .variants
            .values()
            .filter(|v| v.genotype.is_heterozygous())
            .count();

        self.quality_metrics.snp_count = total;
        self.quality_metrics.no_call_rate = no_calls as f32 / total as f32;
        self.quality_metrics.heterozygosity_rate = heterozygous as f32 / total as f32;
    }
}

/// Helper function to normalize chromosome names
pub fn normalize_chromosome(chrom: &str) -> String {
    let chrom = chrom.trim().to_uppercase();

    // Remove "CHR" or "CHROM" prefix
    let chrom = if chrom.starts_with("CHR") {
        &chrom[3..]
    } else if chrom.starts_with("CHROM") {
        &chrom[5..]
    } else {
        &chrom
    };

    // Handle X, Y, MT
    match chrom {
        "X" => "X".to_string(),
        "Y" => "Y".to_string(),
        "MT" | "M" => "MT".to_string(),
        _ => {
            // Try to parse as number
            if let Ok(num) = chrom.parse::<u8>() {
                if num >= 1 && num <= 22 {
                    num.to_string()
                } else {
                    chrom.to_string()
                }
            } else {
                chrom.to_string()
            }
        }
    }
}

/// Helper function to parse genotype from string
pub fn parse_genotype(genotype_str: &str, ref_allele: &str, _alt_alleles: &[String]) -> Genotype {
    if genotype_str.is_empty() || genotype_str == "--" || genotype_str == ".." {
        return Genotype::NoCall;
    }

    // Handle VCF-style genotypes (0/0, 0/1, 1/1, etc.)
    if genotype_str.contains('/') || genotype_str.contains('|') {
        return Genotype::from_string(genotype_str);
    }

    // Handle raw allele strings (AA, AT, TT, etc.)
    if genotype_str.len() == 2 {
        let alleles: Vec<char> = genotype_str.chars().collect();
        if alleles[0] == alleles[1] {
            if alleles[0].to_string() == ref_allele {
                Genotype::HomozygousReference
            } else {
                Genotype::HomozygousAlternate
            }
        } else {
            Genotype::Heterozygous
        }
    } else if genotype_str.len() == 1 {
        // Single allele - treat as homozygous
        if genotype_str == ref_allele {
            Genotype::HomozygousReference
        } else {
            Genotype::HomozygousAlternate
        }
    } else {
        Genotype::NoCall
    }
}

/// Helper to open file with optional gzip decompression
pub fn open_file(path: &Path) -> Result<Box<dyn BufRead>> {
    let file =
        File::open(path).with_context(|| format!("Failed to open file: {}", path.display()))?;

    let reader: Box<dyn BufRead> = if path.extension().map(|e| e == "gz").unwrap_or(false) {
        Box::new(BufReader::new(GzDecoder::new(file)))
    } else {
        Box::new(BufReader::new(file))
    };

    Ok(reader)
}

/// Helper to detect delimiter in a file
pub fn detect_delimiter(line: &str) -> char {
    let tabs = line.matches('\t').count();
    let commas = line.matches(',').count();
    let spaces = line.matches(' ').count();

    if tabs > commas && tabs > spaces {
        '\t'
    } else if commas > tabs && commas > spaces {
        ','
    } else if spaces > 0 {
        ' '
    } else {
        '\t'
    }
}
